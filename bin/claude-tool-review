#!/usr/bin/env python3
# /// script
# requires-python = ">=3.10"
# ///
"""Claude Code PreToolUse hook for validating tool calls."""

import json
import os
import re
import sys
from pathlib import Path

STATE_FILE = Path.home() / ".cache" / "claude-tool-review-disabled"


def is_enabled() -> bool:
    return not STATE_FILE.exists()


def cmd_enable():
    STATE_FILE.unlink(missing_ok=True)
    print("claude-tool-review enabled")


def cmd_disable():
    STATE_FILE.parent.mkdir(parents=True, exist_ok=True)
    STATE_FILE.touch()
    print("claude-tool-review disabled")


def cmd_status():
    print("enabled" if is_enabled() else "disabled")


def check_bash_find(command: str) -> str | None:
    """Reject find commands, suggest fd."""
    if re.match(r"^\s*find\s", command):
        return "Use `fd` instead of `find`. fd uses regex by default and is faster."
    return None


def check_git_redundant_c(command: str, cwd: str | None = None) -> str | None:
    """Reject git -C when pointing to current directory."""
    match = re.match(r"^\s*git\s+-C\s+([^\s]+)", command)
    if match:
        target = match.group(1)
        cwd = cwd or os.getcwd()
        target_resolved = os.path.realpath(os.path.expanduser(target))
        if target_resolved == os.path.realpath(cwd):
            return "Don't use `-C` for git commands in the current directory."
    return None


def check_git_add_all(command: str) -> str | None:
    """Reject git add -A or git add . - prefer explicit file staging."""
    if re.match(r"^\s*git\s+add\s+(-A|\.)\s*$", command):
        return "Stage specific files instead of using `git add -A` or `git add .` for atomic commits."
    return None


BASH_CHECKS = [
    check_bash_find,
    check_git_redundant_c,
    check_git_add_all,
]


def validate_bash(tool_input: dict, cwd: str | None = None) -> dict | None:
    """Validate Bash tool calls."""
    command = tool_input.get("command", "")
    for check in BASH_CHECKS:
        if check == check_git_redundant_c:
            reason = check(command, cwd)
        else:
            reason = check(command)
        if reason:
            return {"continue": False, "stopReason": reason}
    return None


TOOL_VALIDATORS = {
    "Bash": validate_bash,
}


def run_hook():
    if not is_enabled():
        print(json.dumps({"continue": True}))
        return

    data = json.load(sys.stdin)
    tool_name = data.get("tool_name", "")
    cwd = data.get("cwd")

    if validator := TOOL_VALIDATORS.get(tool_name):
        if result := validator(data.get("tool_input", {}), cwd):
            print(json.dumps(result))
            return

    print(json.dumps({"continue": True}))


COMMANDS = {
    "enable": cmd_enable,
    "disable": cmd_disable,
    "status": cmd_status,
}


def main():
    if len(sys.argv) > 1:
        cmd = sys.argv[1]
        if cmd in COMMANDS:
            COMMANDS[cmd]()
        else:
            print(f"usage: {sys.argv[0]} [enable|disable|status]", file=sys.stderr)
            sys.exit(1)
    else:
        run_hook()


if __name__ == "__main__":
    main()
