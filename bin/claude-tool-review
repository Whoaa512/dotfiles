#!/usr/bin/env python3
# /// script
# requires-python = ">=3.10"
# ///
"""Claude Code PreToolUse hook for validating tool calls."""

import fnmatch
import json
import os
import re
import sys
from pathlib import Path
from urllib.parse import urlparse

STATE_FILE = Path.home() / ".cache" / "claude-tool-review-disabled"
SETTINGS_FILE = Path.home() / ".claude" / "settings.json"


def load_allow_patterns() -> list[str]:
    """Load allow patterns from settings.json."""
    try:
        data = json.loads(SETTINGS_FILE.read_text())
        return data.get("permissions", {}).get("allow", [])
    except Exception:
        return []


def parse_allow_patterns(patterns: list[str]) -> dict:
    """Parse patterns into tool-specific lists."""
    bash_prefixes = []
    bash_exact = []
    read_globs = []
    webfetch_domains = []

    for p in patterns:
        if p.startswith("Bash(") and p.endswith(")"):
            inner = p[5:-1]
            if inner.endswith(":*"):
                bash_prefixes.append(inner[:-2])
            else:
                bash_exact.append(inner)
        elif p.startswith("Read(") and p.endswith(")"):
            read_globs.append(p[5:-1])
        elif p.startswith("WebFetch(domain:") and p.endswith(")"):
            webfetch_domains.append(p[16:-1])

    return {
        "bash_prefixes": bash_prefixes,
        "bash_exact": bash_exact,
        "read_globs": read_globs,
        "webfetch_domains": webfetch_domains,
    }


def is_bash_allowed(command: str, parsed: dict) -> bool:
    """Check if bash command matches allow list."""
    cmd = command.strip()
    if cmd in parsed["bash_exact"]:
        return True
    for prefix in parsed["bash_prefixes"]:
        if cmd.startswith(prefix):
            return True
    return False


def is_temp_path(file_path: str) -> bool:
    """Check if path is in a temp directory."""
    return file_path.startswith(("/tmp/", "/private/tmp/"))


def is_read_allowed(file_path: str, parsed: dict) -> bool:
    """Check if read path matches allow globs."""
    if is_temp_path(file_path):
        return True
    for pattern in parsed["read_globs"]:
        if fnmatch.fnmatch(file_path, pattern):
            return True
    return False


def is_webfetch_allowed(url: str, parsed: dict) -> bool:
    """Check if url domain is allowed."""
    try:
        domain = urlparse(url).netloc
        for allowed in parsed["webfetch_domains"]:
            if domain == allowed or domain.endswith("." + allowed):
                return True
    except Exception:
        pass
    return False


def check_allow_list(tool_name: str, tool_input: dict, parsed: dict) -> bool:
    """Return True if tool call should be auto-approved."""
    if tool_name == "Bash":
        return is_bash_allowed(tool_input.get("command", ""), parsed)
    if tool_name == "Read":
        return is_read_allowed(tool_input.get("file_path", ""), parsed)
    if tool_name in ("Write", "Edit"):
        return is_temp_path(tool_input.get("file_path", ""))
    if tool_name == "WebFetch":
        return is_webfetch_allowed(tool_input.get("url", ""), parsed)
    return False


def is_enabled() -> bool:
    return not STATE_FILE.exists()


def cmd_enable():
    STATE_FILE.unlink(missing_ok=True)
    print("claude-tool-review enabled")


def cmd_disable():
    STATE_FILE.parent.mkdir(parents=True, exist_ok=True)
    STATE_FILE.touch()
    print("claude-tool-review disabled")


def cmd_status():
    print("enabled" if is_enabled() else "disabled")


def check_bash_find(command: str) -> str | None:
    """Reject find commands, suggest fd."""
    if re.match(r"^\s*find\s", command):
        return "Use `fd` instead of `find`. fd uses regex by default and is faster."
    return None


def check_git_redundant_c(command: str, cwd: str | None = None) -> str | None:
    """Reject git -C when pointing to current directory."""
    match = re.match(r"^\s*git\s+-C\s+([^\s]+)", command)
    if match:
        target = match.group(1)
        # Allow -C for worktree paths
        if "/.worktrees/" in target:
            return None
        cwd = cwd or os.getcwd()
        target_resolved = os.path.realpath(os.path.expanduser(target))
        if target_resolved == os.path.realpath(cwd):
            return "Don't use `-C` for git commands in the current directory."
    return None


def check_git_add_all(command: str) -> str | None:
    """Reject git add -A or git add . - prefer explicit file staging."""
    if re.match(r"^\s*git\s+add\s+(-A|\.)\s*$", command):
        return "Stage specific files instead of using `git add -A` or `git add .` for atomic commits."
    return None


BASH_CHECKS = [
    check_bash_find,
    check_git_redundant_c,
    check_git_add_all,
]


def allow() -> dict:
    """Return an allow response for PreToolUse hooks."""
    return {
        "hookSpecificOutput": {
            "hookEventName": "PreToolUse",
            "permissionDecision": "allow",
        }
    }


def deny(reason: str) -> dict:
    """Return a deny response for PreToolUse hooks."""
    return {
        "hookSpecificOutput": {
            "hookEventName": "PreToolUse",
            "permissionDecision": "deny",
            "permissionDecisionReason": reason,
        }
    }


def validate_bash(tool_input: dict, cwd: str | None = None) -> dict | None:
    """Validate Bash tool calls."""
    command = tool_input.get("command", "")
    for check in BASH_CHECKS:
        if check == check_git_redundant_c:
            reason = check(command, cwd)
        else:
            reason = check(command)
        if reason:
            return deny(reason)
    return None


TOOL_VALIDATORS = {
    "Bash": validate_bash,
}


DEBUG_LOG = Path("/tmp/claude-tool-review-debug.log")


def debug_log(msg: str):
    if DEBUG_LOG.exists():
        with DEBUG_LOG.open("a") as f:
            f.write(f"{msg}\n")


def run_hook():
    if not is_enabled():
        print(json.dumps({"continue": True}))
        return

    data = json.load(sys.stdin)
    tool_name = data.get("tool_name", "")
    tool_input = data.get("tool_input", {})
    cwd = data.get("cwd")

    debug_log(f"tool={tool_name} input={tool_input} cwd={cwd}")

    # Auto-approve if in allow list
    parsed = parse_allow_patterns(load_allow_patterns())
    if check_allow_list(tool_name, tool_input, parsed):
        debug_log("allow_list=True -> auto-approve")
        print(json.dumps(allow()))
        return

    # Auto-approve git -C for worktree paths
    if tool_name == "Bash":
        cmd = tool_input.get("command", "")
        match = re.match(r"^\s*git\s+-C\s+([^\s]+)", cmd)
        if match and "/.worktrees/" in match.group(1):
            debug_log("worktree path -> auto-approve")
            print(json.dumps(allow()))
            return

    # Run validators for potential blocks
    if validator := TOOL_VALIDATORS.get(tool_name):
        if result := validator(tool_input, cwd):
            reason = result["hookSpecificOutput"]["permissionDecisionReason"]
            debug_log(f"deny: {reason}")
            print(reason, file=sys.stderr, flush=True)
            sys.exit(2)

    debug_log("passthrough")
    print(json.dumps({"continue": True}), flush=True)


COMMANDS = {
    "enable": cmd_enable,
    "disable": cmd_disable,
    "status": cmd_status,
}


def main():
    if len(sys.argv) > 1:
        cmd = sys.argv[1]
        if cmd in COMMANDS:
            COMMANDS[cmd]()
        else:
            print(f"usage: {sys.argv[0]} [enable|disable|status]", file=sys.stderr)
            sys.exit(1)
    else:
        run_hook()


if __name__ == "__main__":
    main()
