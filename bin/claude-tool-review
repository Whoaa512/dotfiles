#!/usr/bin/env python3
# /// script
# requires-python = ">=3.10"
# ///
"""Claude Code PreToolUse hook for validating tool calls."""

import fnmatch
import json
import os
import re
import sys
from pathlib import Path
from urllib.parse import urlparse

STATE_FILE = Path.home() / ".cache" / "claude-tool-review-disabled"

# Allow patterns from settings.json - auto-approve these
BASH_ALLOW_PREFIXES = [
    "rg", "fd", "cat", "ls", "mkdir", "git add", "git check-ignore",
    "go build", "go test", "tmux has-session", "tmux new-session",
    "tmux list-sessions", "tmux kill-session", "tmux capture-pane",
    "tmux send-keys", "ssh pihole", "bazel build", "bazel test",
    "git commit", "grep", "cp", "tree", "jq",
    "gh pr checks", "gh pr status", "gh pr diff", "gh pr list", "gh pr view",
    "gh issue list", "gh issue view", "gh issue status",
    "gh run list", "gh run view", "gh workflow list", "gh workflow view",
    "gh release list", "gh release view", "gh repo list", "gh repo view",
    "gh search repos", "gh search issues", "gh search prs",
    "gh search commits", "gh search code", "gh status", "gh auth status",
    "gh gist list", "gh gist view", "bazel info", "uuidgen", "chmod",
    "bd init", "bd sync", "bd --no-daemon sync", "bd create", "bd comment",
    "bd list", "bd ready", "bd show", "bd update", "bd close", "bd search",
    "bd dep", "bd blocked", "bd stats", "bd reopen", "npm install",
    "devtools pages", "devtools go", "devtools snap", "devtools screenshot",
    "devtools click", "devtools hover", "devtools fill", "devtools eval",
    "devtools console", "devtools network", "ln", "claude-tool-review status",
    "claude-tool-review disable", "claude-tool-review enable", "uv run",
]
BASH_ALLOW_EXACT = [
    'echo "Exit code: $?"',
]
READ_ALLOW_GLOBS = [
    "/private/tmp/**",
    "/tmp/**",
    "/Users/cjw/code/cj/**",
]
WEBFETCH_ALLOW_DOMAINS = [
    "pkg.go.dev",
    "github.com",
]


def is_bash_allowed(command: str) -> bool:
    """Check if bash command matches allow list."""
    cmd = command.strip()
    if cmd in BASH_ALLOW_EXACT:
        return True
    for prefix in BASH_ALLOW_PREFIXES:
        if cmd.startswith(prefix):
            return True
    return False


def is_read_allowed(file_path: str) -> bool:
    """Check if read path matches allow globs."""
    for pattern in READ_ALLOW_GLOBS:
        if fnmatch.fnmatch(file_path, pattern):
            return True
    return False


def is_webfetch_allowed(url: str) -> bool:
    """Check if url domain is allowed."""
    try:
        domain = urlparse(url).netloc
        for allowed in WEBFETCH_ALLOW_DOMAINS:
            if domain == allowed or domain.endswith("." + allowed):
                return True
    except Exception:
        pass
    return False


def check_allow_list(tool_name: str, tool_input: dict) -> bool:
    """Return True if tool call should be auto-approved."""
    if tool_name == "Bash":
        return is_bash_allowed(tool_input.get("command", ""))
    if tool_name == "Read":
        return is_read_allowed(tool_input.get("file_path", ""))
    if tool_name == "WebFetch":
        return is_webfetch_allowed(tool_input.get("url", ""))
    return False


def is_enabled() -> bool:
    return not STATE_FILE.exists()


def cmd_enable():
    STATE_FILE.unlink(missing_ok=True)
    print("claude-tool-review enabled")


def cmd_disable():
    STATE_FILE.parent.mkdir(parents=True, exist_ok=True)
    STATE_FILE.touch()
    print("claude-tool-review disabled")


def cmd_status():
    print("enabled" if is_enabled() else "disabled")


def check_bash_find(command: str) -> str | None:
    """Reject find commands, suggest fd."""
    if re.match(r"^\s*find\s", command):
        return "Use `fd` instead of `find`. fd uses regex by default and is faster."
    return None


def check_git_redundant_c(command: str, cwd: str | None = None) -> str | None:
    """Reject git -C when pointing to current directory."""
    match = re.match(r"^\s*git\s+-C\s+([^\s]+)", command)
    if match:
        target = match.group(1)
        cwd = cwd or os.getcwd()
        target_resolved = os.path.realpath(os.path.expanduser(target))
        if target_resolved == os.path.realpath(cwd):
            return "Don't use `-C` for git commands in the current directory."
    return None


def check_git_add_all(command: str) -> str | None:
    """Reject git add -A or git add . - prefer explicit file staging."""
    if re.match(r"^\s*git\s+add\s+(-A|\.)\s*$", command):
        return "Stage specific files instead of using `git add -A` or `git add .` for atomic commits."
    return None


BASH_CHECKS = [
    check_bash_find,
    check_git_redundant_c,
    check_git_add_all,
]


def validate_bash(tool_input: dict, cwd: str | None = None) -> dict | None:
    """Validate Bash tool calls."""
    command = tool_input.get("command", "")
    for check in BASH_CHECKS:
        if check == check_git_redundant_c:
            reason = check(command, cwd)
        else:
            reason = check(command)
        if reason:
            return {"continue": False, "stopReason": reason}
    return None


TOOL_VALIDATORS = {
    "Bash": validate_bash,
}


def run_hook():
    if not is_enabled():
        print(json.dumps({"continue": True}))
        return

    data = json.load(sys.stdin)
    tool_name = data.get("tool_name", "")
    tool_input = data.get("tool_input", {})
    cwd = data.get("cwd")

    # Auto-approve if in allow list
    if check_allow_list(tool_name, tool_input):
        print(json.dumps({"continue": True}))
        return

    # Run validators for potential blocks
    if validator := TOOL_VALIDATORS.get(tool_name):
        if result := validator(tool_input, cwd):
            print(json.dumps(result))
            return

    print(json.dumps({"continue": True}))


COMMANDS = {
    "enable": cmd_enable,
    "disable": cmd_disable,
    "status": cmd_status,
}


def main():
    if len(sys.argv) > 1:
        cmd = sys.argv[1]
        if cmd in COMMANDS:
            COMMANDS[cmd]()
        else:
            print(f"usage: {sys.argv[0]} [enable|disable|status]", file=sys.stderr)
            sys.exit(1)
    else:
        run_hook()


if __name__ == "__main__":
    main()
